generator client {
  provider = "prisma-client-js"
  output   = "../../prisma/generated/postgres"
}

datasource db {
  provider = "postgresql"
  url      = env("POSTGRES_URL")
}

model Profile {
  id          String     @id @default(uuid())
  userId      String     @unique
  name        String
  nickname    String? // Display name
  imageUrl    String
  email       String
  status      UserStatus @default(ONLINE)
  bio         String? // About me section
  website     String? // Personal website
  socialMedia Json? // Social media links (Twitter, Instagram, etc.)
  createdAt   DateTime   @default(now())
  updatedAt   DateTime   @updatedAt

  servers                   Server[]
  members                   Member[]
  channels                  Channel[]
  conversations             Conversation[]
  groupConversations        GroupConversationMember[]
  groupConversationsCreated GroupConversation[]
  friendRequestsSent        FriendRequest[]           @relation("FriendRequestRequester")
  friendRequestsReceived    FriendRequest[]           @relation("FriendRequestTarget")
  messageRequestsSent       MessageRequest[]          @relation("MessageRequestRequester")
  messageRequestsReceived   MessageRequest[]          @relation("MessageRequestTarget")
  followsSent               Follow[]                  @relation("FollowerProfile")
  followsReceived           Follow[]                  @relation("FollowingProfile")
  serverFollows             ServerFollow[]            @relation("ServerFollowerProfile")
  notificationsReceived     Notification[]            @relation("NotificationRecipient")
  notificationsRelated      Notification[]            @relation("NotificationRelatedProfile")

  @@map("profiles")
}

model Server {
  id                   String         @id @default(uuid())
  name                 String
  imageUrl             String
  inviteCode           String         @unique
  category             ServerCategory @default(POPULAR)
  profileId            String
  profile              Profile        @relation(fields: [profileId], references: [id], onDelete: Cascade)
  members              Member[]
  channels             Channel[]
  serverFollows        ServerFollow[]
  notificationsRelated Notification[] @relation("NotificationRelatedServer")
  createdAt            DateTime       @default(now())
  updatedAt            DateTime       @updatedAt

  @@map("servers")
}

model Member {
  id                     String                    @id @default(uuid())
  role                   MemberRole                @default(GUEST)
  profileId              String
  profile                Profile                   @relation(fields: [profileId], references: [id], onDelete: Cascade)
  serverId               String
  server                 Server                    @relation(fields: [serverId], references: [id], onDelete: Cascade)
  conversationsInitiated Conversation[]            @relation("MemberOne")
  conversationsReceived  Conversation[]            @relation("MemberTwo")
  groupConversations     GroupConversationMember[]
  groupMessages          GroupMessage[]
  directMessages         DirectMessage[]
  createdAt              DateTime                  @default(now())
  updatedAt              DateTime                  @updatedAt

  @@unique([profileId, serverId])
  @@map("members")
}

model Channel {
  id        String      @id @default(uuid())
  name      String
  type      ChannelType @default(TEXT)
  profileId String
  profile   Profile     @relation(fields: [profileId], references: [id], onDelete: Cascade)
  serverId  String
  server    Server      @relation(fields: [serverId], references: [id], onDelete: Cascade)
  createdAt DateTime    @default(now())
  updatedAt DateTime    @updatedAt

  @@map("channels")
}

model Conversation {
  id          String          @id @default(uuid())
  memberOneId String
  memberOne   Member          @relation("MemberOne", fields: [memberOneId], references: [id], onDelete: Cascade)
  memberTwoId String
  memberTwo   Member          @relation("MemberTwo", fields: [memberTwoId], references: [id], onDelete: Cascade)
  profileId   String
  profile     Profile         @relation(fields: [profileId], references: [id], onDelete: Cascade)
  messages    DirectMessage[]
  createdAt   DateTime        @default(now())
  updatedAt   DateTime        @updatedAt

  @@unique([memberOneId, memberTwoId])
  @@map("conversations")
}

model GroupConversation {
  id        String                    @id @default(uuid())
  name      String
  imageUrl  String?
  profileId String
  profile   Profile                   @relation(fields: [profileId], references: [id], onDelete: Cascade)
  members   GroupConversationMember[]
  messages  GroupMessage[]
  createdAt DateTime                  @default(now())
  updatedAt DateTime                  @updatedAt

  @@map("group_conversations")
}

model GroupConversationMember {
  id                  String            @id @default(uuid())
  role                GroupMemberRole   @default(GUEST)
  profileId           String
  profile             Profile           @relation(fields: [profileId], references: [id], onDelete: Cascade)
  memberId            String
  member              Member            @relation(fields: [memberId], references: [id], onDelete: Cascade)
  groupConversationId String
  groupConversation   GroupConversation @relation(fields: [groupConversationId], references: [id], onDelete: Cascade)
  createdAt           DateTime          @default(now())
  updatedAt           DateTime          @updatedAt

  @@unique([profileId, groupConversationId])
  @@map("group_conversation_members")
}

model GroupMessage {
  id                  String            @id @default(uuid())
  content             String
  fileUrl             String?
  deleted             Boolean           @default(false)
  memberId            String
  member              Member            @relation(fields: [memberId], references: [id], onDelete: Cascade)
  groupConversationId String
  groupConversation   GroupConversation @relation(fields: [groupConversationId], references: [id], onDelete: Cascade)
  createdAt           DateTime          @default(now())
  updatedAt           DateTime          @updatedAt

  @@map("group_messages")
}

model DirectMessage {
  id             String       @id @default(uuid())
  content        String
  fileUrl        String?
  deleted        Boolean      @default(false)
  memberId       String
  member         Member       @relation(fields: [memberId], references: [id], onDelete: Cascade)
  conversationId String
  conversation   Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  createdAt      DateTime     @default(now())
  updatedAt      DateTime     @updatedAt

  @@map("direct_messages")
}

model FriendRequest {
  id                 String              @id @default(uuid())
  requesterProfileId String
  requesterProfile   Profile             @relation("FriendRequestRequester", fields: [requesterProfileId], references: [id], onDelete: Cascade)
  targetProfileId    String
  targetProfile      Profile             @relation("FriendRequestTarget", fields: [targetProfileId], references: [id], onDelete: Cascade)
  status             FriendRequestStatus @default(PENDING)
  createdAt          DateTime            @default(now())
  updatedAt          DateTime            @updatedAt

  @@unique([requesterProfileId, targetProfileId])
  @@map("friend_requests")
}

model MessageRequest {
  id                 String               @id @default(uuid())
  requesterProfileId String
  requesterProfile   Profile              @relation("MessageRequestRequester", fields: [requesterProfileId], references: [id], onDelete: Cascade)
  targetProfileId    String
  targetProfile      Profile              @relation("MessageRequestTarget", fields: [targetProfileId], references: [id], onDelete: Cascade)
  message            String
  status             MessageRequestStatus @default(PENDING)
  createdAt          DateTime             @default(now())
  updatedAt          DateTime             @updatedAt

  @@map("message_requests")
}

model Follow {
  id                 String   @id @default(uuid())
  followerProfileId  String
  followerProfile    Profile  @relation("FollowerProfile", fields: [followerProfileId], references: [id], onDelete: Cascade)
  followingProfileId String
  followingProfile   Profile  @relation("FollowingProfile", fields: [followingProfileId], references: [id], onDelete: Cascade)
  createdAt          DateTime @default(now())

  @@unique([followerProfileId, followingProfileId])
  @@map("follows")
}

model ServerFollow {
  id                String   @id @default(uuid())
  followerProfileId String
  followerProfile   Profile  @relation("ServerFollowerProfile", fields: [followerProfileId], references: [id], onDelete: Cascade)
  serverId          String
  server            Server   @relation(fields: [serverId], references: [id], onDelete: Cascade)
  createdAt         DateTime @default(now())

  @@unique([followerProfileId, serverId])
  @@map("server_follows")
}

model Notification {
  id                 String           @id @default(uuid())
  recipientProfileId String
  recipientProfile   Profile          @relation("NotificationRecipient", fields: [recipientProfileId], references: [id], onDelete: Cascade)
  type               NotificationType
  title              String
  content            String
  relatedProfileId   String?
  relatedProfile     Profile?         @relation("NotificationRelatedProfile", fields: [relatedProfileId], references: [id], onDelete: SetNull)
  relatedServerId    String?
  relatedServer      Server?          @relation("NotificationRelatedServer", fields: [relatedServerId], references: [id], onDelete: SetNull)
  isRead             Boolean          @default(false)
  createdAt          DateTime         @default(now())

  @@map("notifications")
}

enum MemberRole {
  ADMIN
  MODERATOR
  GUEST
}

enum GroupMemberRole {
  ADMIN
  MODERATOR
  GUEST
}

enum ChannelType {
  TEXT
  AUDIO
  VIDEO
}

enum FriendRequestStatus {
  PENDING
  ACCEPTED
  REJECTED
}

enum MessageRequestStatus {
  PENDING
  ACCEPTED
  REJECTED
}

enum ServerCategory {
  POPULAR
  CHRISTIANITY
  BUSINESS
  SOCIAL
  SCIENCE_AND_EDUCATION
}

enum NotificationType {
  FRIEND_ACTIVITY
  SERVER_ACTIVITY
  FRIEND_ONLINE
  SERVER_JOIN
  MESSAGE_MENTION
  SERVER_INVITE
}

enum UserStatus {
  ONLINE
  IDLE
  DO_NOT_DISTURB
  INVISIBLE
}
